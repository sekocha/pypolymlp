# How to Use Polynomial MLPs with Other Calculator Tools

## LAMMPS
To use polynomial MLPs in LAMMPS, please use the
[polymlp-lammps-package](https://github.com/sekocha/lammps-polymlp-package).
Molecular dynamics and other calculations available in LAMMPS, including those using user packages, can be performed by following the standard LAMMPS documentation, except for the specification of `pair_style` and `pair_coeff`.

The following LAMMPS input commands specify a machine learning potential (e.g., for a binary Ti–Al system):
```
pair_style  polymlp
pair_coeff * * polymlp.lammps Ti Al
```
If you are using a polynomial MLP generated by `pypolymlp` (version ≥ 0.9.0), the potential file can be specified as follows:
```
pair_style  polymlp
pair_coeff * * polymlp.yaml Ti Al
```

### Hybrid polynomial MLPs in LAMMPS
In hybrid polynomial MLPs, the potential energy is represented as a sum of multiple polynomial MLPs, where the regression coefficients of all models are determined simultaneously.
When performing simulations with hybrid polynomial MLPs in LAMMPS, [pair_style hybrid command](https://www.afs.enea.it/software/lammps/doc19/html/pair_hybrid.html) can be used:
```
pair_style hybrid polymlp polymlp polymlp
pair_coeff * * polymlp.yaml.1 Ti Al
pair_coeff * * polymlp.yaml.2 Ti Al
pair_coeff * * polymlp.yaml.3 Ti Al
```

## ASE
To use polynomial MLPs in ASE, generate a calculator instance as shown below.
This calculator can be used for various calculations provided by ASE, in accordance with the ASE documentation.
```python
from pypolymlp.calculator.utils.ase_calculator import PolymlpASECalculator

calculator = PolymlpASECalculator(pot="polymlp.yaml")
```

## Phonopy
```python
from phonopy import Phonopy
from pypolymlp.utils.phonopy_utils import phonopy_cell_to_structure
from pypolymlp.api.pypolymlp_calc import PypolymlpCalc

supercell_matrix = np.diag([2, 2, 2])
ph = Phonopy(unitcell, supercell_matrix) # unitcell: PhonopyAtoms
ph.generate_displacements(distance=0.01)
structures = [phonopy_cell_to_structure(cell) for cell in ph.supercells_with_displacements]

polymlp = PypolymlpCalc(pot="polymlp.yaml")
_, forces, _ = polymlp.eval(structures) # Forces. shape=(n_disp, 3, natom), unit: eV/angstrom.
forces = np.array(forces).transpose((0, 2, 1))

ph.forces = forces
ph.produce_force_constants()
```
