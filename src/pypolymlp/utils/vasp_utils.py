"""Utilities for vasp files"""

from typing import Optional

import numpy as np

from pypolymlp.core.data_format import PolymlpStructure
from pypolymlp.utils.yaml_utils import save_cell


def print_poscar(st: PolymlpStructure):
    """Print structure in POSCAR format."""
    if st.comment is not None:
        print(st.comment)
    else:
        print("Generated by pypolymlp")

    print("1.0")
    for n in st.axis.T:
        print(
            "  ",
            "{0:15.15f}".format(n[0]),
            "{0:15.15f}".format(n[1]),
            "{0:15.15f}".format(n[2]),
        )
    index = 0
    print(" ", end="")
    for n in st.n_atoms:
        print(st.elements[index], " ", end="")
        index += n
    print()
    print(" ", end="")
    for n in st.n_atoms:
        print(n, " ", end="")
    print()
    print("Direct")
    for n in st.positions.T:
        print(
            "  ",
            "{0:15.15f}".format(n[0]),
            "{0:15.15f}".format(n[1]),
            "{0:15.15f}".format(n[2]),
        )


def write_poscar_file(
    st: PolymlpStructure,
    filename: str = "poscar_pypolymlp",
    header: Optional[str] = None,
):
    """Write structure in POSCAR file."""
    f = open(filename, "w")

    if header is not None:
        print(header, file=f)
    else:
        if st.comment is not None:
            print(st.comment, file=f)
        else:
            print("Generated by pypolymlp", file=f)

    print("1.0", file=f)
    for n in st.axis.T:
        print(
            "  ",
            "{0:15.15f}".format(n[0]),
            "{0:15.15f}".format(n[1]),
            "{0:15.15f}".format(n[2]),
            file=f,
        )
    index = 0
    print(" ", end="", file=f)
    for n in st.n_atoms:
        if n > 0:
            print(st.elements[index], " ", end="", file=f)
            index += n
        else:
            print("Z  ", end="", file=f)
    print("", file=f)
    print(" ", end="", file=f)
    for n in st.n_atoms:
        print(n, " ", end="", file=f)
    print("", file=f)
    print("Direct", file=f)
    for n in st.positions.T:
        print(
            "  ",
            "{0:15.15f}".format(float(n[0])),
            "{0:15.15f}".format(float(n[1])),
            "{0:15.15f}".format(float(n[2])),
            file=f,
        )

    f.close()


def load_electronic_properties_from_vasprun(
    input_filename: str = "vasprun.xml",
    output_filename: Optional[str] = None,
    temp_max: float = 1000.0,
    temp_step: float = 10.0,
):
    """Load electronic properties from vasprun.xml.

    phonopy is required.
    """
    from phonopy.interface.vasp import parse_vasprunxml

    # from pypolymlp.utils.electron import ElectronProperties
    from pypolymlp.utils.phonopy_utils import phonopy_cell_to_structure

    vxml = parse_vasprunxml(input_filename)
    st = phonopy_cell_to_structure(vxml.cell)

    weights = vxml.k_weights
    eigenvalues = vxml.eigenvalues[:, :, :, 0]
    n_electrons = vxml.NELECT
    el = ElectronProperties(eigenvalues, weights, n_electrons)
    el.run(temp_max, temp_step)

    if output_filename is not None:
        with open(output_filename, mode="w") as f:
            save_cell(st, tag="structure", file=f)
            print("unit:", file=f)
            print("  free_energy   : eV/cell", file=f)
            print("  energy        : eV/cell", file=f)
            print("  entropy       : eV/K/cell", file=f)
            print("  specific_heat : eV/K/cell", file=f)
            print("", file=f)

            print("properties:", file=f)
            for t, e, s, helm, sh in zip(
                el.temperatures,
                el.energy,
                el.entropy,
                el.free_energy,
                el.cv,
            ):
                print("- temperature:  ", t, file=f)
                print("  free_energy:  ", helm, file=f)
                print("  energy:       ", e, file=f)
                print("  entropy:      ", s, file=f)
                print("  specific_heat:", sh, file=f)
                print("", file=f)

    return (st, el)


class ElectronProperties:
    """Class for calculating electronic properties at finite temperatures."""

    def __init__(self, eigenvalues: np.ndarray, weights: np.ndarray, n_electrons: int):
        """Init method."""
        from phonopy.qha.electron import ElectronFreeEnergy

        self._efe = ElectronFreeEnergy(eigenvalues, weights, n_electrons)
        self._energies = None
        self._entropies = None
        self._free_energies = None
        self._cvs = None
        self._temperatures = None

    def run(self, temp_max: float = 1000, temp_step: float = 10):
        """Calculate properties at temperatures."""
        self._temperatures = np.arange(0.0, temp_max + 0.1, temp_step)
        self._energies = []
        self._entropies = []
        self._free_energies = []
        self._cvs = []
        for temp in self._temperatures:
            self._efe.run(T=temp)
            self._energies.append(self._efe.energy)
            self._entropies.append(self._efe.entropy)
            self._free_energies.append(self._efe.free_energy)
            self._cvs.append(self._calc_cv(temp))

        self._free_energies = np.array(self._free_energies) - self._free_energies[0]
        self._energies = np.array(self._energies) - self._energies[0]
        self._entropies = np.array(self._entropies)
        self._entropies[1:] /= self._temperatures[1:]
        self._cvs = np.array(self._cvs)
        return self

    def _calc_df_dT(self, epsilon: np.array, mu: float, T: int) -> float:
        """Calculate df/dT at temperature T."""
        from phonopy.units import Kb

        de = (epsilon - mu) / (Kb * T)
        de = np.where(de < 100, de, 100.0)  # To avoid overflow
        de = np.where(de > -100, de, -100.0)  # To avoid underflow
        return (de * np.exp(de)) / (T * ((np.exp(de) + 1) ** 2))

    def _calc_cv(self, T: int) -> float:
        """Calculate Cv at temperature T.

        Return
        ------
        Cv in eV/K.
        """
        if T == 0:
            return 0.0
        self._efe.run(T)
        eigvals = self._efe._eigenvalues.reshape(len(self._efe._weights), -1)
        df_dT = self._calc_df_dT(eigvals, self._efe._mu, T)

        # TODO: Results must be tested.
        cv = self._efe._g * np.sum(
            self._efe._weights * np.sum((eigvals - self._efe._mu) * df_dT, axis=1)
        )
        return cv
        # return cv * EvTokJmol * 1000  # J/K/mol

    @property
    def free_energy(self):
        """Return free energy.

        Return
        ------
        Free energies in eV.
        """
        return self._free_energies

    @property
    def energy(self):
        """Return energy.

        Return
        ------
        Energies in eV.
        """
        return self._energies

    @property
    def entropy(self):
        """Return entropy.

        Return
        ------
        Entropies in eV/K.
        """
        return self._entropies

    @property
    def cv(self):
        """Return specific heat.

        Return
        ------
        Cv in eV/K.
        """
        return self._cvs

    @property
    def temperatures(self):
        """Return temperature."""
        return self._temperatures
